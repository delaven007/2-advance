"""
进程，线程，单进程的效率测试
使用单进程，分别执行count   io 10遍  记录时间
使用10个线程，每个执行count ， io 10遍  记录时间
使用10个进程，每个执行count ， io 10遍  记录时间
2.总结进程，线程区别
"""
# from threading import Thread
# from time import sleep,ctime
# count=0
# def get_count():
#     pass
# while count<10:
#     t=Thread(target=get_count,args=(1,),kwargs={})
#     t.start()
#     print("start_time:",ctime)
#     t.join()
#     print("end_time:",ctime)
#     count+=1
from multiprocessing import Process,Semaphore
from time import sleep
import  os
from time import ctime
import time
#创建信号量
sem=Semaphore(1)

def handle():
    sem.acquire()
    print("%d 执行任务"%os.getpid(),"start_time:", time.time())
    sleep(1)
    print("%d  执行完毕"%os.getpid(),"end_time:", time.time())
    sem.release()

for i in range(10):
    p=Process(target=handle)
    p.start()
    p.join()


"""
1．调度
在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。
而在引入线程的操作系统中，则把线程作为调度和分派的基本单位。
而把进程作 为资源拥有的基本单位，使传统进程的两个属性分开，线程便能轻装运行，
从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，
在 由一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。
2．并发性
在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，
亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使 用系统资源和提高系统吞吐量。
例如，在一个未引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因而被阻塞时，
便没有其它的文件服 务进程来提供服务。在引入了线程的操作系统中，可以在一个文件服务进程中，
设置多个服务线程，当第一个线程等待时，文件服务进程中的第二个线程可以继续运 行；
当第二个线程阻塞时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统吞吐量。
3．拥有资源
不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，
它可以拥有自己的资源。一般地说，线程自己不拥有系统资源(也有一点必 不可少的资源)，
但它可以访问其隶属进程的资源。亦即，一个进程的代码段、数据段以及系统资源，
如已打开的文件、I/O设备等，可供问一进程的其它所有线 程共享。
4．系统开销
由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。
因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类 似地，
在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。
而线程切换只须保存和设置少量寄存器的内容，并 不涉及存储器管理方面的操作。可见，
进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，
致使它们之间的同步和通信的实现，也变得比较容易。在有的系统中，线程的切换、同步和通信都无须
"""